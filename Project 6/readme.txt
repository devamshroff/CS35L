readme.txt - a breif after-action report of the Multithreaded performance
homework.

The main point of interest of this lab was to change up main.c so that
it supports multithreads. After thorough inspection of the code, I realized
that the big for loop that interated through each pixel using width and
everything inside it was the prime candidate for parallelism.

That whole portion of code had to be moved to a helper function named
multiFunc, which was necessary simply because of the way pthread and its
arguments are set up. A notable problem here was the fact that the loops
used some of the variables that were declared right before them in main.
Therefore, I had to make them global variables that could be shared by
each thread.

There were some changes in the outer for loops that needed to be made in order
to make effective use of multithreading. For the outer loop of looping through
each pixel of the image. I decided to start the loop iteration at thread_id,
and increment by nthreads in the attempt to evenly divide up all the pixels
among the threads and to avoid race conditions. This way each pixel is only
used by one thread. Another problem I noticed was that there could be race
conditions in the printing of all the pixels. Therefore, I create a
temporary 3d array to store the values generated by each thread, and then
I print them out in the main function.

I had some issues with compilation errors and syntactic errors
that were due to my own fault - like redifining variables I had made global
in my main function. But I eventually solved them using the gdb and reviewing
the pthread create and join syntax on the TA slides.

Looking at the performance of multithreading, it was clear that increasing the
number of threads leads to less real execution time and therefore better
performance. This makes sense because all the more threads, the more pixels
that can be generated at the same time.




